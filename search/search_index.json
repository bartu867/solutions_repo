{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection Physics | Mechanics | KW1 Assignment Author: Bartu867 Date: March 29, 2025 Mechanics Project \ud83d\udcda Problem 1: Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation \u2022 Derivation of Equations of Motion Starting from Newton\u2019s Second Law: \\[\\vec{F}=m\\vec{a}\\] In the absence of air resistance, the only force acting on the projectile (after launch) is gravity: \\[\\vec{a}=(0,-g)\\] where \\(g\\) is the gravitational acceleration. Thus, the equations of motion are: In horizontal ( \\(x\\) ) direction: \\[\\frac{d^2x}{dt^2}=0\\quad\\Rightarrow\\quad\\frac{dx}{dt}=v_{0x}=v_0\\cos(\\theta)\\] In vertical ( \\(y\\) ) direction: \\[\\frac{d^2y}{dt^2}=-g\\quad\\Rightarrow\\quad\\frac{dy}{dt}=v_{0y}-gt=v_0\\sin(\\theta)-gt\\] Integrating once more: Horizontal position: \\[x(t)=v_0\\cos(\\theta)t\\] Vertical position: \\[y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2\\] \u2022 Varying Initial Conditions Initial velocity \\(v_0\\) : Higher \\(v_0\\) increases both maximum height and range. Gravitational acceleration \\(g\\) : Higher \\(g\\) reduces flight time and range. Launch height : Here assumed zero; can be generalized for non-zero launch heights. 2. Analysis of the Range \u2022 Derivation of Range Formula The projectile hits the ground again when \\(y(T)=0\\) . Solving: \\[0=v_0\\sin(\\theta)T-\\frac{1}{2}gT^2\\] which gives: \\[T=\\frac{2v_0\\sin(\\theta)}{g}\\] Range \\(R\\) is the horizontal distance traveled during flight: \\[R=x(T)=v_0\\cos(\\theta)T\\] Substituting for \\(T\\) : \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\] \u2022 Parameter Dependence \\(v_0\\) : Range is proportional to \\(v_0^2\\) . \\(g\\) : Range is inversely proportional to \\(g\\) . \\(\\theta\\) : Range depends on \\(\\sin(2\\theta)\\) , maximized at \\(45^\\circ\\) . 3. Practical Applications Uneven Terrain : Modify landing conditions for non-zero final height. Air Resistance : Add drag force proportional to velocity. Different Planetary Gravities : Adjust \\(g\\) to simulate other environments (e.g., Moon, Mars). 4. Implementation in Python import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 50 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = [15, 45, 75] # Launch angles in degrees colors = ['r', 'g', 'b'] # Colors for different angles # Time of flight for each angle (when y = 0) def time_of_flight(v0, angle, g): angle_rad = np.radians(angle) return (2 * v0 * np.sin(angle_rad)) / g # Function to compute x and y positions at time t def projectile_motion(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Time points for the plot (up to time of flight) time_max = max(time_of_flight(v0, angle, g) for angle in angles) t_values = np.linspace(0, time_max, num=500) # Plot projectile motion for each angle plt.figure(figsize=(10, 6)) for angle, color in zip(angles, colors): x_values = [] y_values = [] for t in t_values: x, y = projectile_motion(v0, angle, g, t) if y < 0: # Stop the simulation when projectile hits the ground break x_values.append(x) y_values.append(y) plt.plot(x_values, y_values, label=f'Angle = {angle}\u00b0', color=color) # Labels and title plt.title('Projectile Motion for Different Angles', fontsize=16) plt.xlabel('Horizontal Distance (m)', fontsize=14) plt.ylabel('Vertical Distance (m)', fontsize=14) plt.legend() plt.grid(True) plt.show()","title":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"Physics | Mechanics | KW1 Assignment Author: Bartu867 Date: March 29, 2025","title":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-project","text":"","title":"Mechanics Project"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection_1","text":"","title":"\ud83d\udcda Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-equations-of-motion","text":"Starting from Newton\u2019s Second Law: \\[\\vec{F}=m\\vec{a}\\] In the absence of air resistance, the only force acting on the projectile (after launch) is gravity: \\[\\vec{a}=(0,-g)\\] where \\(g\\) is the gravitational acceleration. Thus, the equations of motion are: In horizontal ( \\(x\\) ) direction: \\[\\frac{d^2x}{dt^2}=0\\quad\\Rightarrow\\quad\\frac{dx}{dt}=v_{0x}=v_0\\cos(\\theta)\\] In vertical ( \\(y\\) ) direction: \\[\\frac{d^2y}{dt^2}=-g\\quad\\Rightarrow\\quad\\frac{dy}{dt}=v_{0y}-gt=v_0\\sin(\\theta)-gt\\] Integrating once more: Horizontal position: \\[x(t)=v_0\\cos(\\theta)t\\] Vertical position: \\[y(t)=v_0\\sin(\\theta)t-\\frac{1}{2}gt^2\\]","title":"\u2022 Derivation of Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#varying-initial-conditions","text":"Initial velocity \\(v_0\\) : Higher \\(v_0\\) increases both maximum height and range. Gravitational acceleration \\(g\\) : Higher \\(g\\) reduces flight time and range. Launch height : Here assumed zero; can be generalized for non-zero launch heights.","title":"\u2022 Varying Initial Conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#derivation-of-range-formula","text":"The projectile hits the ground again when \\(y(T)=0\\) . Solving: \\[0=v_0\\sin(\\theta)T-\\frac{1}{2}gT^2\\] which gives: \\[T=\\frac{2v_0\\sin(\\theta)}{g}\\] Range \\(R\\) is the horizontal distance traveled during flight: \\[R=x(T)=v_0\\cos(\\theta)T\\] Substituting for \\(T\\) : \\[R=\\frac{v_0^2\\sin(2\\theta)}{g}\\]","title":"\u2022 Derivation of Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameter-dependence","text":"\\(v_0\\) : Range is proportional to \\(v_0^2\\) . \\(g\\) : Range is inversely proportional to \\(g\\) . \\(\\theta\\) : Range depends on \\(\\sin(2\\theta)\\) , maximized at \\(45^\\circ\\) .","title":"\u2022 Parameter Dependence"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Uneven Terrain : Modify landing conditions for non-zero final height. Air Resistance : Add drag force proportional to velocity. Different Planetary Gravities : Adjust \\(g\\) to simulate other environments (e.g., Moon, Mars).","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt # Parameters v0 = 50 # Initial velocity (m/s) g = 9.81 # Gravitational acceleration (m/s^2) angles = [15, 45, 75] # Launch angles in degrees colors = ['r', 'g', 'b'] # Colors for different angles # Time of flight for each angle (when y = 0) def time_of_flight(v0, angle, g): angle_rad = np.radians(angle) return (2 * v0 * np.sin(angle_rad)) / g # Function to compute x and y positions at time t def projectile_motion(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y # Time points for the plot (up to time of flight) time_max = max(time_of_flight(v0, angle, g) for angle in angles) t_values = np.linspace(0, time_max, num=500) # Plot projectile motion for each angle plt.figure(figsize=(10, 6)) for angle, color in zip(angles, colors): x_values = [] y_values = [] for t in t_values: x, y = projectile_motion(v0, angle, g, t) if y < 0: # Stop the simulation when projectile hits the ground break x_values.append(x) y_values.append(y) plt.plot(x_values, y_values, label=f'Angle = {angle}\u00b0', color=color) # Labels and title plt.title('Projectile Motion for Different Angles', fontsize=16) plt.xlabel('Horizontal Distance (m)', fontsize=14) plt.ylabel('Vertical Distance (m)', fontsize=14) plt.legend() plt.grid(True) plt.show()","title":"4. Implementation in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"\ud83d\udd2c Physics Assignment \u2013 KW1 Topic: Mechanics \u2013 Oscillations & Motion Author: Bartu867 Date: March 27, 2025 1. Theoretical Foundation The motion of a forced damped pendulum is described by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) : Angular displacement as a function of time - \\( b \\) : Damping coefficient - \\( g \\) : Gravitational acceleration - \\( L \\) : Length of the pendulum - \\( A \\) : Amplitude of the driving force - \\( \\omega \\) : Angular frequency of the external periodic force Small-Angle Approximation When the angular displacement is small, we can use the approximation \\( \\sin(\\theta) \\approx \\theta \\) . This simplifies the equation to: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This form is linear and easier to analyze using analytical or numerical methods. Resonance and System Energy Resonance occurs when the driving frequency \\( \\omega \\) is close to the system\u2019s natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the energy input from the external force matches the natural oscillation frequency, potentially leading to large amplitude oscillations. Damping reduces these amplitudes by dissipating energy. 2. Analysis of Dynamics The dynamics of a forced damped pendulum are significantly affected by three key parameters: Damping coefficient (b): Controls how quickly the motion dies out. Higher damping leads to faster energy loss and smaller oscillations. Driving amplitude (A): The strength of the external periodic force. Increasing it can lead to more energetic motion and potentially chaotic behavior. Driving frequency (\u03c9): Determines how often the external force acts. When it matches the natural frequency \\( \\omega_0 \\) , resonance may occur. Regular vs Chaotic Motion By varying the above parameters, the system can display: Regular (Periodic) Motion: When parameters are moderate, the pendulum swings in a predictable, repeating manner. Quasiperiodic Motion: The motion consists of multiple frequencies that never quite repeat. Chaotic Motion: When certain thresholds are crossed, small changes in initial conditions can lead to drastically different outcomes. This is a hallmark of deterministic chaos. The transition from regular to chaotic motion is particularly interesting because it illustrates how nonlinearity and external forcing can result in unpredictable behavior in otherwise deterministic systems. 3. Practical Applications The forced damped pendulum serves as a model for various real-world systems that involve oscillations, damping, and external driving forces. These systems span across different fields: \ud83d\udd39 Engineering Applications Suspension bridges: Wind and traffic can act as periodic forces, while damping comes from internal friction and structural design. Energy harvesting devices: Oscillating systems can convert kinetic energy into electrical energy, especially when tuned near resonance. \ud83d\udd39 Electrical Systems Driven RLC Circuits: The voltage in an RLC (Resistor\u2013Inductor\u2013Capacitor) circuit under an alternating current behaves similarly to a forced damped pendulum. The current corresponds to the angular velocity, and the circuit elements represent damping, mass, and restoring force. \ud83d\udd39 Biomechanics Human gait dynamics: The swinging motion of limbs can be modeled as a damped driven oscillator, especially when considering walking or running with external rhythmic inputs (e.g., treadmill, exoskeleton support). These analogies help in designing control systems, optimizing performance, and understanding failure mechanisms under resonance or chaotic conditions. 4. Implementation To explore the dynamics of a forced damped pendulum beyond analytical solutions, we use computational simulations. \ud83d\udd39 Numerical Modeling import numpy as np # Constants g = 9.81 L = 1.0 b = 0.5 A = 1.2 omega = 2/3 def pendulum_deriv(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Time settings t_span = (0, 50) t_eval = np.linspace(*t_span, 1000) # Initial conditions y0 = [0.2, 0.0] # Solve using Runge-Kutta sol = solve_ivp(pendulum_deriv, t_span, y0, t_eval=t_eval, method='RK45') # Plot \u03b8 vs time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angular Displacement vs Time') plt.xlabel('Time [s]') plt.ylabel('\u03b8 [rad]') plt.grid(True) plt.legend() plt.tight_layout() plt.show() The nonlinear differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] is solved using numerical methods such as the Runge-Kutta method. This allows us to simulate the motion for arbitrary initial conditions and parameter values. Python Code: Differential Equation import numpy as np # Constants g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of driving force omega = 2/3 # driving frequency # Differential equation system def pendulum_deriv(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] Time Evolution of the Pendulum We simulate and visualize the angular displacement \\( \\theta(t) \\) over time using the Runge-Kutta method ( solve_ivp from scipy.integrate ). This helps us understand how the pendulum responds to different damping and driving conditions. import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Time settings t_span = (0, 50) t_eval = np.linspace(*t_span, 1000) # Initial conditions y0 = [0.2, 0.0] # Solve using Runge-Kutta sol = solve_ivp(pendulum_deriv, t_span, y0, t_eval=t_eval, method='RK45') # Plot \u03b8 vs time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angular Displacement vs Time') plt.xlabel('Time [s]') plt.ylabel('\u03b8 [rad]') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Phase Space Diagram The phase space plot of angular velocity \\( \\omega(t) \\) versus angular position \\( \\theta(t) \\) provides insights into the nature of the motion. It helps distinguish between regular, damped, or chaotic behavior. # Phase space plot: \u03b8 vs \u03c9 theta_vals = sol.y[0] omega_vals = sol.y[1] plt.figure(figsize=(6, 6)) plt.plot(theta_vals, omega_vals, lw=0.7) plt.title('Phase Space Diagram (\u03b8 vs \u03c9)') plt.xlabel('\u03b8 [rad]') plt.ylabel('\u03c9 [rad/s]') plt.grid(True) plt.tight_layout() plt.show() Poincar\u00e9 Section A Poincar\u00e9 section is a tool used to detect chaotic behavior in dynamic systems. By sampling the state of the pendulum at regular intervals equal to the driving period, we can reveal patterns in the long-term behavior. # Driving period T_drive = 2 * np.pi / omega # Sample points: every driving period poincare_t = np.arange(0, 50, T_drive) # Interpolate solution at poincare times from scipy.interpolate import interp1d interp_theta = interp1d(sol.t, sol.y[0]) interp_omega = interp1d(sol.t, sol.y[1]) theta_p = interp_theta(poincare_t) omega_p = interp_omega(poincare_t) # Plot Poincar\u00e9 section plt.figure(figsize=(6, 6)) plt.plot(theta_p, omega_p, 'o', markersize=2) plt.title(\"Poincar\u00e9 Section (Sampled Every Period)\") plt.xlabel(\"\u03b8 [rad]\") plt.ylabel(\"\u03c9 [rad/s]\") plt.grid(True) plt.tight_layout() plt.show() 5. Deliverables A Markdown document with Python script implementing the simulation of a forced damped pendulum using numerical methods. A detailed explanation of the differential equation , including small-angle approximation and resonance analysis. Graphical representations of the system's behavior: Time evolution plots \\( \\theta(t) \\) Phase space diagrams \\( \\theta \\) vs \\( \\omega \\) Poincar\u00e9 sections for detecting chaos A discussion on model limitations , such as: The use of small-angle approximation in early theory Ideal sinusoidal driving force (non-realistic in some applications) No consideration of nonlinear damping or friction Suggestions for future work: Introducing nonlinear damping (e.g., air resistance proportional to \\( \\omega^2 \\) ) Using non-periodic or random external forces Exploring bifurcation diagrams and Lyapunov exponents for chaos analysis This assignment bridges theoretical physics and computational simulation, enhancing understanding of real-world oscillatory systems and nonlinear dynamics through both mathematical modeling and visualization. ```","title":"\ud83d\udd2c Physics Assignment \u2013 KW1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physics-assignment-kw1","text":"Topic: Mechanics \u2013 Oscillations & Motion Author: Bartu867 Date: March 27, 2025","title":"\ud83d\udd2c Physics Assignment \u2013 KW1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum is described by the nonlinear second-order differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta(t) \\) : Angular displacement as a function of time - \\( b \\) : Damping coefficient - \\( g \\) : Gravitational acceleration - \\( L \\) : Length of the pendulum - \\( A \\) : Amplitude of the driving force - \\( \\omega \\) : Angular frequency of the external periodic force","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"When the angular displacement is small, we can use the approximation \\( \\sin(\\theta) \\approx \\theta \\) . This simplifies the equation to: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This form is linear and easier to analyze using analytical or numerical methods.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-and-system-energy","text":"Resonance occurs when the driving frequency \\( \\omega \\) is close to the system\u2019s natural frequency: \\[ \\omega_0 = \\sqrt{\\frac{g}{L}} \\] At resonance, the energy input from the external force matches the natural oscillation frequency, potentially leading to large amplitude oscillations. Damping reduces these amplitudes by dissipating energy.","title":"Resonance and System Energy"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"The dynamics of a forced damped pendulum are significantly affected by three key parameters: Damping coefficient (b): Controls how quickly the motion dies out. Higher damping leads to faster energy loss and smaller oscillations. Driving amplitude (A): The strength of the external periodic force. Increasing it can lead to more energetic motion and potentially chaotic behavior. Driving frequency (\u03c9): Determines how often the external force acts. When it matches the natural frequency \\( \\omega_0 \\) , resonance may occur.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#regular-vs-chaotic-motion","text":"By varying the above parameters, the system can display: Regular (Periodic) Motion: When parameters are moderate, the pendulum swings in a predictable, repeating manner. Quasiperiodic Motion: The motion consists of multiple frequencies that never quite repeat. Chaotic Motion: When certain thresholds are crossed, small changes in initial conditions can lead to drastically different outcomes. This is a hallmark of deterministic chaos. The transition from regular to chaotic motion is particularly interesting because it illustrates how nonlinearity and external forcing can result in unpredictable behavior in otherwise deterministic systems.","title":"Regular vs Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum serves as a model for various real-world systems that involve oscillations, damping, and external driving forces. These systems span across different fields:","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#engineering-applications","text":"Suspension bridges: Wind and traffic can act as periodic forces, while damping comes from internal friction and structural design. Energy harvesting devices: Oscillating systems can convert kinetic energy into electrical energy, especially when tuned near resonance.","title":"\ud83d\udd39 Engineering Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#electrical-systems","text":"Driven RLC Circuits: The voltage in an RLC (Resistor\u2013Inductor\u2013Capacitor) circuit under an alternating current behaves similarly to a forced damped pendulum. The current corresponds to the angular velocity, and the circuit elements represent damping, mass, and restoring force.","title":"\ud83d\udd39 Electrical Systems"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#biomechanics","text":"Human gait dynamics: The swinging motion of limbs can be modeled as a damped driven oscillator, especially when considering walking or running with external rhythmic inputs (e.g., treadmill, exoskeleton support). These analogies help in designing control systems, optimizing performance, and understanding failure mechanisms under resonance or chaotic conditions.","title":"\ud83d\udd39 Biomechanics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"To explore the dynamics of a forced damped pendulum beyond analytical solutions, we use computational simulations.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-modeling","text":"import numpy as np # Constants g = 9.81 L = 1.0 b = 0.5 A = 1.2 omega = 2/3 def pendulum_deriv(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Time settings t_span = (0, 50) t_eval = np.linspace(*t_span, 1000) # Initial conditions y0 = [0.2, 0.0] # Solve using Runge-Kutta sol = solve_ivp(pendulum_deriv, t_span, y0, t_eval=t_eval, method='RK45') # Plot \u03b8 vs time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angular Displacement vs Time') plt.xlabel('Time [s]') plt.ylabel('\u03b8 [rad]') plt.grid(True) plt.legend() plt.tight_layout() plt.show() The nonlinear differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + b \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] is solved using numerical methods such as the Runge-Kutta method. This allows us to simulate the motion for arbitrary initial conditions and parameter values.","title":"\ud83d\udd39 Numerical Modeling"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code-differential-equation","text":"import numpy as np # Constants g = 9.81 # gravitational acceleration (m/s^2) L = 1.0 # length of pendulum (m) b = 0.5 # damping coefficient A = 1.2 # amplitude of driving force omega = 2/3 # driving frequency # Differential equation system def pendulum_deriv(t, y): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -b * omega_theta - (g / L) * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt]","title":"Python Code: Differential Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#time-evolution-of-the-pendulum","text":"We simulate and visualize the angular displacement \\( \\theta(t) \\) over time using the Runge-Kutta method ( solve_ivp from scipy.integrate ). This helps us understand how the pendulum responds to different damping and driving conditions. import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Time settings t_span = (0, 50) t_eval = np.linspace(*t_span, 1000) # Initial conditions y0 = [0.2, 0.0] # Solve using Runge-Kutta sol = solve_ivp(pendulum_deriv, t_span, y0, t_eval=t_eval, method='RK45') # Plot \u03b8 vs time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angular Displacement vs Time') plt.xlabel('Time [s]') plt.ylabel('\u03b8 [rad]') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Time Evolution of the Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-space-diagram","text":"The phase space plot of angular velocity \\( \\omega(t) \\) versus angular position \\( \\theta(t) \\) provides insights into the nature of the motion. It helps distinguish between regular, damped, or chaotic behavior. # Phase space plot: \u03b8 vs \u03c9 theta_vals = sol.y[0] omega_vals = sol.y[1] plt.figure(figsize=(6, 6)) plt.plot(theta_vals, omega_vals, lw=0.7) plt.title('Phase Space Diagram (\u03b8 vs \u03c9)') plt.xlabel('\u03b8 [rad]') plt.ylabel('\u03c9 [rad/s]') plt.grid(True) plt.tight_layout() plt.show()","title":"Phase Space Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#poincare-section","text":"A Poincar\u00e9 section is a tool used to detect chaotic behavior in dynamic systems. By sampling the state of the pendulum at regular intervals equal to the driving period, we can reveal patterns in the long-term behavior. # Driving period T_drive = 2 * np.pi / omega # Sample points: every driving period poincare_t = np.arange(0, 50, T_drive) # Interpolate solution at poincare times from scipy.interpolate import interp1d interp_theta = interp1d(sol.t, sol.y[0]) interp_omega = interp1d(sol.t, sol.y[1]) theta_p = interp_theta(poincare_t) omega_p = interp_omega(poincare_t) # Plot Poincar\u00e9 section plt.figure(figsize=(6, 6)) plt.plot(theta_p, omega_p, 'o', markersize=2) plt.title(\"Poincar\u00e9 Section (Sampled Every Period)\") plt.xlabel(\"\u03b8 [rad]\") plt.ylabel(\"\u03c9 [rad/s]\") plt.grid(True) plt.tight_layout() plt.show()","title":"Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-deliverables","text":"A Markdown document with Python script implementing the simulation of a forced damped pendulum using numerical methods. A detailed explanation of the differential equation , including small-angle approximation and resonance analysis. Graphical representations of the system's behavior: Time evolution plots \\( \\theta(t) \\) Phase space diagrams \\( \\theta \\) vs \\( \\omega \\) Poincar\u00e9 sections for detecting chaos A discussion on model limitations , such as: The use of small-angle approximation in early theory Ideal sinusoidal driving force (non-realistic in some applications) No consideration of nonlinear damping or friction Suggestions for future work: Introducing nonlinear damping (e.g., air resistance proportional to \\( \\omega^2 \\) ) Using non-periodic or random external forces Exploring bifurcation diagrams and Lyapunov exponents for chaos analysis This assignment bridges theoretical physics and computational simulation, enhancing understanding of real-world oscillatory systems and nonlinear dynamics through both mathematical modeling and visualization. ```","title":"5. Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \u2013 Orbital Period and Orbital Radius Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025 \ud83c\udfaf Goal Understand and derive the relationship between the square of the orbital period and the cube of the orbital radius (Kepler\u2019s Third Law). Analyze this for circular orbits and simulate the behavior using Python for different celestial bodies. \ud83e\udde0 Theoretical Background Kepler\u2019s Third Law states that the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( r \\) for planets orbiting the same central body: \\[ T^2 \\propto r^3 \\] For circular orbits, using Newton\u2019s law of gravitation and centripetal force, the orbital period can be derived as: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Where: - \\( T \\) : orbital period (seconds) - \\( r \\) : orbital radius (meters) - \\( G \\) : gravitational constant \\( (6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2) \\) - \\( M \\) : mass of the central body (kg) This formula shows that the orbital period increases as the radius increases. \ud83d\udcbb Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.9722e24 # mass of the Earth (kg) # Orbital radius values (from 7e6 to 4.2e7 meters) r = np.linspace(7e6, 4.2e7, 500) # Orbital period calculation using Kepler's 3rd Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # in seconds # Plotting plt.figure(figsize=(10, 6)) plt.plot(r / 1e6, T / 3600, color=\"orange\") # Convert r to million meters, T to hours plt.title(\"Orbital Period vs Orbital Radius\") plt.xlabel(\"Orbital Radius (Million meters)\") plt.ylabel(\"Orbital Period (Hours)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 1 \u2013 Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025","title":"Problem 1 \u2013 Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#goal","text":"Understand and derive the relationship between the square of the orbital period and the cube of the orbital radius (Kepler\u2019s Third Law). Analyze this for circular orbits and simulate the behavior using Python for different celestial bodies.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-background","text":"Kepler\u2019s Third Law states that the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( r \\) for planets orbiting the same central body: \\[ T^2 \\propto r^3 \\] For circular orbits, using Newton\u2019s law of gravitation and centripetal force, the orbital period can be derived as: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Where: - \\( T \\) : orbital period (seconds) - \\( r \\) : orbital radius (meters) - \\( G \\) : gravitational constant \\( (6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2) \\) - \\( M \\) : mass of the central body (kg) This formula shows that the orbital period increases as the radius increases.","title":"\ud83e\udde0 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.9722e24 # mass of the Earth (kg) # Orbital radius values (from 7e6 to 4.2e7 meters) r = np.linspace(7e6, 4.2e7, 500) # Orbital period calculation using Kepler's 3rd Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # in seconds # Plotting plt.figure(figsize=(10, 6)) plt.plot(r / 1e6, T / 3600, color=\"orange\") # Convert r to million meters, T to hours plt.title(\"Orbital Period vs Orbital Radius\") plt.xlabel(\"Orbital Radius (Million meters)\") plt.ylabel(\"Orbital Period (Hours)\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025 \ud83c\udfaf Goal Examine how escape velocity varies with the mass and radius of a celestial body. Understand the concept of escape velocity and simulate how different planetary parameters affect it using Python. \ud83d\udcd8 Theoretical Background The escape velocity \\( v_e \\) is the minimum speed required for an object to break free from the gravitational pull of a massive body, without any further propulsion. The formula is derived from energy conservation: [ v_e = \\sqrt{\\frac{2GM}{R}} ] Where: - \\( v_e \\) : escape velocity (m/s) - \\( G \\) : gravitational constant \\( 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M \\) : mass of the celestial body (kg) - \\( R \\) : radius of the celestial body (m) \ud83d\udcbb Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674e-11 # Gravitational constant Example celestial body masses (kg) and radii (m) masses = np.array([5.972e24, 6.39e23, 1.898e27]) # Earth, Mars, Jupiter radii = np.array([6.371e6, 3.3895e6, 6.9911e7]) # Earth, Mars, Jupiter names = ['Earth', 'Mars', 'Jupiter'] Escape velocity calculation v_escape = np.sqrt(2 * G * masses / radii) Plotting plt.figure(figsize=(10,6)) plt.bar(names, v_escape, color='crimson') plt.title(\"Escape Velocity for Different Celestial Bodies\") plt.ylabel(\"Escape Velocity (m/s)\") plt.grid(axis='y') plt.tight_layout() plt.show()","title":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocity-and-celestial-bodies","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025","title":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#goal","text":"Examine how escape velocity varies with the mass and radius of a celestial body. Understand the concept of escape velocity and simulate how different planetary parameters affect it using Python.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theoretical-background","text":"The escape velocity \\( v_e \\) is the minimum speed required for an object to break free from the gravitational pull of a massive body, without any further propulsion. The formula is derived from energy conservation: [ v_e = \\sqrt{\\frac{2GM}{R}} ] Where: - \\( v_e \\) : escape velocity (m/s) - \\( G \\) : gravitational constant \\( 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M \\) : mass of the celestial body (kg) - \\( R \\) : radius of the celestial body (m)","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"G = 6.674e-11 # Gravitational constant","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#example-celestial-body-masses-kg-and-radii-m","text":"masses = np.array([5.972e24, 6.39e23, 1.898e27]) # Earth, Mars, Jupiter radii = np.array([6.371e6, 3.3895e6, 6.9911e7]) # Earth, Mars, Jupiter names = ['Earth', 'Mars', 'Jupiter']","title":"Example celestial body masses (kg) and radii (m)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity-calculation","text":"v_escape = np.sqrt(2 * G * masses / radii)","title":"Escape velocity calculation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plotting","text":"plt.figure(figsize=(10,6)) plt.bar(names, v_escape, color='crimson') plt.title(\"Escape Velocity for Different Celestial Bodies\") plt.ylabel(\"Escape Velocity (m/s)\") plt.grid(axis='y') plt.tight_layout() plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 29, 2025 \ud83c\udfaf Goal Simulate and analyze the possible trajectories of a payload released near Earth from a moving spacecraft. Determine whether the object enters orbit, falls to Earth, or escapes into space depending on initial conditions. \ud83d\udcd8 Theoretical Background When an object is released from a spacecraft near Earth, it will follow a trajectory determined by its initial velocity and position relative to Earth's gravity. Using Newton's law of universal gravitation: \\[ F = \\frac{GMm}{r^2} \\] The motion of the payload follows Newton's second law: \\[ F = ma \\Rightarrow a = \\frac{GM}{r^2} \\] Depending on the initial velocity vector: If \\( v < v_{\\text{orbit}} \\) , it falls back to Earth. If \\( v = v_{\\text{orbit}} \\) , it enters circular orbit. If \\( v > v_{\\text{escape}} \\) , it escapes Earth's gravity. We will simulate the trajectory by numerically integrating the motion under gravitational acceleration. \ud83d\udcbb Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R = 6.371e6 # radius of Earth (m) Initial conditions r0 = np.array([7.0e6, 0]) # initial position (just above Earth surface) v0 = np.array([0, 8000]) # initial velocity in m/s (tangential) Simulation parameters dt = 1 # time step (seconds) steps = 10000 # number of steps Arrays to store trajectory positions = np.zeros((steps, 2)) velocities = np.zeros((steps, 2)) Set initial values positions[0] = r0 velocities[0] = v0 Simulation loop for i in range(1, steps): r = positions[i-1] v = velocities[i-1] dist = np.linalg.norm(r) if dist < R: positions = positions[:i] # Break if the object is within Earth's radius break # Gravitational acceleration a = -G * M * r / dist**3 # Update velocity and position (Euler method) velocities[i] = v + a * dt positions[i] = r + velocities[i] * dt Plotting the trajectory x = positions[:, 0] / 1000 # Convert to km y = positions[:, 1] / 1000 # Convert to km plt.figure(figsize=(8,8)) plt.plot(x, y, label='Payload trajectory') circle = plt.Circle((0, 0), R / 1000, color='blue', alpha=0.5, label='Earth') plt.gca().add_patch(circle) plt.xlabel(\"x position (km)\") plt.ylabel(\"y position (km)\") plt.title(\"Trajectory of Payload Released Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 29, 2025","title":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#goal","text":"Simulate and analyze the possible trajectories of a payload released near Earth from a moving spacecraft. Determine whether the object enters orbit, falls to Earth, or escapes into space depending on initial conditions.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"When an object is released from a spacecraft near Earth, it will follow a trajectory determined by its initial velocity and position relative to Earth's gravity. Using Newton's law of universal gravitation: \\[ F = \\frac{GMm}{r^2} \\] The motion of the payload follows Newton's second law: \\[ F = ma \\Rightarrow a = \\frac{GM}{r^2} \\] Depending on the initial velocity vector: If \\( v < v_{\\text{orbit}} \\) , it falls back to Earth. If \\( v = v_{\\text{orbit}} \\) , it enters circular orbit. If \\( v > v_{\\text{escape}} \\) , it escapes Earth's gravity. We will simulate the trajectory by numerically integrating the motion under gravitational acceleration.","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R = 6.371e6 # radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"r0 = np.array([7.0e6, 0]) # initial position (just above Earth surface) v0 = np.array([0, 8000]) # initial velocity in m/s (tangential)","title":"Initial conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"dt = 1 # time step (seconds) steps = 10000 # number of steps","title":"Simulation parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#arrays-to-store-trajectory","text":"positions = np.zeros((steps, 2)) velocities = np.zeros((steps, 2))","title":"Arrays to store trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#set-initial-values","text":"positions[0] = r0 velocities[0] = v0","title":"Set initial values"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-loop","text":"for i in range(1, steps): r = positions[i-1] v = velocities[i-1] dist = np.linalg.norm(r) if dist < R: positions = positions[:i] # Break if the object is within Earth's radius break # Gravitational acceleration a = -G * M * r / dist**3 # Update velocity and position (Euler method) velocities[i] = v + a * dt positions[i] = r + velocities[i] * dt","title":"Simulation loop"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting-the-trajectory","text":"x = positions[:, 0] / 1000 # Convert to km y = positions[:, 1] / 1000 # Convert to km plt.figure(figsize=(8,8)) plt.plot(x, y, label='Payload trajectory') circle = plt.Circle((0, 0), R / 1000, color='blue', alpha=0.5, label='Earth') plt.gca().add_patch(circle) plt.xlabel(\"x position (km)\") plt.ylabel(\"y position (km)\") plt.title(\"Trajectory of Payload Released Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Plotting the trajectory"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}