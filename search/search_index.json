{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection Physics | Mechanics | KW1 Assignment Author: Bartu867 Date: March 29, 2025 \ud83d\udcd8 1\ufe0f\u20e3 Theoretical Foundation \u2013 Projectile Motion Projectile motion is a classic example of 2D motion under constant acceleration (gravity). It can be broken into two components: horizontal motion and vertical motion . \u2699\ufe0f Governing Equations from Newton\u2019s Laws Newton\u2019s Second Law ( \\(F = ma\\) ) applied in the vertical direction gives constant downward acceleration due to gravity. We ignore air resistance and assume motion starts at ground level. \ud83d\udd39 Horizontal Motion (No Acceleration) Constant velocity (no force in x-direction) Displacement: \\( \\(x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t\\) \\) \ud83d\udd39 Vertical Motion (Constant Acceleration) Acceleration is \\(-g\\) (downward) Displacement: \\( \\(y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2\\) \\) Vertical velocity: \\( \\(v_y(t) = v_0 \\cdot \\sin(\\theta) - gt\\) \\) \ud83e\uddee Time of Flight At landing, \\(y = 0\\) : \\[0 = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2\\] Solving for total time \\(t\\) : \\[t = \\frac{2v_0 \\cdot \\sin(\\theta)}{g}\\] \ud83c\udfaf Range of the Projectile Use total flight time in horizontal displacement: \\[R = x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t\\] Substitute \\(t\\) : \\[R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2v_0 \\cdot \\sin(\\theta)}{g}$$ $$R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g}\\] \ud83d\udd01 Influence of Parameters Initial Velocity ( \\(v_0\\) ): Range increases quadratically with \\(v_0\\) . Doubling \\(v_0\\) results in \\(4\\times\\) the range. Gravitational Acceleration ( \\(g\\) ): Higher \\(g\\) means shorter flight time and range. On the Moon ( \\(g \\approx 1.6\\) ), the range is much longer. Angle ( \\(\\theta\\) ): Range is maximum at \\(\\theta = 45^\\circ\\) . \\(\\sin(2\\theta)\\) creates a symmetric curve around \\(45^\\circ\\) . \ud83e\udde0 Family of Solutions Changing \\(v_0\\) , \\(g\\) , or \\(\\theta\\) generates a family of projectile paths with different ranges and shapes. For example: \\(\\theta = 30^\\circ\\) and \\(\\theta = 60^\\circ\\) \u2192 same range, different height and flight time Different \\(v_0\\) values shift the entire trajectory up/down Different \\(g\\) values (like Moon vs Earth) stretch the flight arc \ud83d\udcbb Python Helper Code (Just for Later Use) ```python import numpy as np Constants g = 9.81 # m/s\u00b2 Range function def range_formula(v0, theta_deg): theta_rad = np.radians(theta_deg) return (v0 ** 2 * np.sin(2 * theta_rad)) / g \ud83d\udcca 2\ufe0f\u20e3 Analysis of the Range \u2013 Numerical Simulation In this section, we simulate projectile range behavior with respect to the launch angle and analyze how initial velocity ( \\(v_0\\) ) and gravitational acceleration ( \\(g\\) ) influence the outcome. \ud83c\udfaf Objective Visualize the function: \\( \\(R(\\theta)=\\frac{v_0^2\\cdot\\sin(2\\theta)}{g}\\) \\) Explore: The symmetry around \\(\\theta=45^\\circ\\) The effect of changing \\(v_0\\) and \\(g\\) Optional: Non-zero launch height (extended model) \ud83d\udcbb Python Code: Range vs Angle (Multiple Cases) ```python import numpy as np import matplotlib.pyplot as plt Constants theta_deg = np.arange(0, 91, 1) # angles from 0\u00b0 to 90\u00b0 theta_rad = np.radians(theta_deg) Function to calculate range def range_formula(v0, g, theta): return (v0**2 * np.sin(2 * theta)) / g Parameters to compare velocities = [50, 100, 150] # m/s gravities = [9.81, 1.62] # Earth & Moon gravity Plot: Range vs Angle for different initial velocities (Earth) plt.figure(figsize=(10, 5)) for v0 in velocities: R = range_formula(v0, 9.81, theta_rad) plt.plot(theta_deg, R, label=f\"v\u2080 = {v0} m/s\") plt.title(\"Range vs Angle for Different Initial Velocities (g = 9.81 m/s\u00b2)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() Plot: Range vs Angle on Earth vs Moon plt.figure(figsize=(10, 5)) for g in gravities: R = range_formula(100, g, theta_rad) label = \"Earth\" if g == 9.81 else \"Moon\" plt.plot(theta_deg, R, label=f\"{label} (g = {g} m/s\u00b2)\") plt.title(\"Range vs Angle: Earth vs Moon (v\u2080 = 100 m/s)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() \ud83c\udf0d 3\ufe0f\u20e3 Practical Applications \u2013 Real-World Relevance of Projectile Motion Projectile motion is more than just a theoretical exercise \u2014 it has significant applications in sports , engineering , and even space science . Understanding the factors that affect a projectile's trajectory allows us to model and optimize systems in various domains. \ud83c\udfc0 Sports Many sports involve curved projectile trajectories. Understanding these helps in performance analysis, training, and even video game physics engines. Soccer : Curved free kicks follow projectile paths, especially when lofted. Basketball : The launch angle of a jump shot determines its chance of scoring. Golf : Club angle and speed determine the ball\u2019s range and height. All of these can be modeled using: \\[R=\\frac{v_0^2\\cdot\\sin(2\\theta)}{g}\\] But real cases often involve drag and spin. \ud83c\udfd7\ufe0f Engineering Engineers use projectile models in designing: Military/defense systems (cannons, missiles, mortars) Fireworks and flare trajectories Ballistics for forensics and law enforcement Precise modeling requires adding: - Air drag (quadratic with speed) - Mass of projectile - Wind vectors \ud83d\ude80 Astrophysics & Space Science In astrophysics, projectile motion generalizes into orbital mechanics . Rocket launches begin with curved trajectories under Earth's gravity Escape velocity and reentry modeling depends on projectile motion with air resistance and changing \\(g\\) Also: - Gravity is not constant: \\( \\(g=\\frac{GM}{r^2}\\) \\) - Multi-stage motion must be modeled piecewise \ud83c\udf04 Uneven Terrain In real life, projectiles may land: On inclined planes Over hills, valleys, or obstacles This breaks the assumption that the launch and landing height are equal. The range formula becomes invalid, and we must solve: \\[y(t)=h+v_0\\cdot\\sin(\\theta)\\cdot t-\\frac{1}{2}gt^2\\] using numerical methods to find \\(t\\) when \\(y(t)=y_{\\text{target}}\\) \ud83c\udf2c\ufe0f External Effects \ud83d\udca8 Air Resistance Air drag opposes motion. It depends on velocity and shape: \\[F_d=\\frac{1}{2}C_d\\rho Av^2\\] This turns motion into a system of nonlinear differential equations. It shortens range and lowers height. \ud83c\udf2a\ufe0f Wind Wind can: - Increase or decrease horizontal velocity - Deflect projectile laterally Simulation must include a horizontal force term. \ud83c\udf15 Variable Gravity Gravity changes with altitude or location: On other planets (e.g., Mars \\(g=3.71\\) ) At high altitudes Or due to large terrain differences Use altitude-based gravity: \\[g(h)=\\frac{GM}{(R+h)^2}\\] for accurate modeling in atmospheric reentry or lunar missions. \u2705 Summary Projectile motion is a versatile model with deep connections to reality. While the idealized equations are helpful, realistic modeling must incorporate: Uneven terrain Drag & wind Non-zero launch/landing heights Planet-specific gravity These improvements enable simulations that match the complexity of real-world systems. \ud83d\udcbb 4\ufe0f\u20e3 Implementation \u2013 Simulating Projectile Motion in Python In this section, we implement a Python-based simulation of projectile motion to analyze how range depends on launch angle, initial velocity, gravity, and launch height. We use the ideal range formula and extend it with optional height-based modeling. \ud83d\udccc Ideal Range Formula The ideal (no air resistance, flat ground) projectile range is given by: \\[R(\\theta)=\\frac{v_0^2\\cdot\\sin(2\\theta)}{g}\\] Where: - \\(R\\) is the range (meters) - \\(v_0\\) is the initial velocity (m/s) - \\(\\theta\\) is the launch angle (degrees) - \\(g\\) is gravitational acceleration (m/s\u00b2) \ud83d\udcbb Python Code: Basic Implementation ```python import numpy as np import matplotlib.pyplot as plt Ideal range function def ideal_range(v0, g, theta_deg): theta_rad = np.radians(theta_deg) return (v0**2 * np.sin(2 * theta_rad)) / g angles = np.arange(0, 91, 1) g = 9.81 velocities = [50, 100, 150] plt.figure(figsize=(10, 5)) for v0 in velocities: ranges = ideal_range(v0, g, angles) plt.plot(angles, ranges, label=f\"v\u2080 = {v0} m/s\") plt.title(\"Projectile Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() gravities = [9.81, 1.62] # Earth and Moon gravity v0 = 100 plt.figure(figsize=(10, 5)) for g_val in gravities: ranges = ideal_range(v0, g_val, angles) label = \"Earth\" if g_val == 9.81 else \"Moon\" plt.plot(angles, ranges, label=f\"{label} (g = {g_val} m/s\u00b2)\") plt.title(\"Range vs Angle: Earth vs Moon (v\u2080 = 100 m/s)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() from scipy.optimize import root_scalar def range_with_height(v0, g, theta_deg, h): theta_rad = np.radians(theta_deg) vy0 = v0 * np.sin(theta_rad) vx0 = v0 * np.cos(theta_rad) def y(t): return h + vy0 * t - 0.5 * g * t**2 sol = root_scalar(y, bracket=[0.01, 100], method='brentq') t_flight = sol.root return vx0 * t_flight heights = [0, 20, 50] v0 = 100 g = 9.81 plt.figure(figsize=(10, 5)) for h in heights: ranges = [range_with_height(v0, g, angle, h) for angle in angles] plt.plot(angles, ranges, label=f\"Launch Height = {h} m\") plt.title(\"Projectile Range vs Angle (with Launch Height)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"Physics | Mechanics | KW1 Assignment Author: Bartu867 Date: March 29, 2025","title":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation-projectile-motion","text":"Projectile motion is a classic example of 2D motion under constant acceleration (gravity). It can be broken into two components: horizontal motion and vertical motion .","title":"\ud83d\udcd8 1\ufe0f\u20e3 Theoretical Foundation \u2013 Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#governing-equations-from-newtons-laws","text":"Newton\u2019s Second Law ( \\(F = ma\\) ) applied in the vertical direction gives constant downward acceleration due to gravity. We ignore air resistance and assume motion starts at ground level.","title":"\u2699\ufe0f Governing Equations from Newton\u2019s Laws"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion-no-acceleration","text":"Constant velocity (no force in x-direction) Displacement: \\( \\(x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t\\) \\)","title":"\ud83d\udd39 Horizontal Motion (No Acceleration)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion-constant-acceleration","text":"Acceleration is \\(-g\\) (downward) Displacement: \\( \\(y(t) = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2\\) \\) Vertical velocity: \\( \\(v_y(t) = v_0 \\cdot \\sin(\\theta) - gt\\) \\)","title":"\ud83d\udd39 Vertical Motion (Constant Acceleration)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#time-of-flight","text":"At landing, \\(y = 0\\) : \\[0 = v_0 \\cdot \\sin(\\theta) \\cdot t - \\frac{1}{2}gt^2\\] Solving for total time \\(t\\) : \\[t = \\frac{2v_0 \\cdot \\sin(\\theta)}{g}\\]","title":"\ud83e\uddee Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-of-the-projectile","text":"Use total flight time in horizontal displacement: \\[R = x(t) = v_0 \\cdot \\cos(\\theta) \\cdot t\\] Substitute \\(t\\) : \\[R = v_0 \\cdot \\cos(\\theta) \\cdot \\frac{2v_0 \\cdot \\sin(\\theta)}{g}$$ $$R = \\frac{v_0^2 \\cdot \\sin(2\\theta)}{g}\\]","title":"\ud83c\udfaf Range of the Projectile"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-parameters","text":"Initial Velocity ( \\(v_0\\) ): Range increases quadratically with \\(v_0\\) . Doubling \\(v_0\\) results in \\(4\\times\\) the range. Gravitational Acceleration ( \\(g\\) ): Higher \\(g\\) means shorter flight time and range. On the Moon ( \\(g \\approx 1.6\\) ), the range is much longer. Angle ( \\(\\theta\\) ): Range is maximum at \\(\\theta = 45^\\circ\\) . \\(\\sin(2\\theta)\\) creates a symmetric curve around \\(45^\\circ\\) .","title":"\ud83d\udd01 Influence of Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#family-of-solutions","text":"Changing \\(v_0\\) , \\(g\\) , or \\(\\theta\\) generates a family of projectile paths with different ranges and shapes. For example: \\(\\theta = 30^\\circ\\) and \\(\\theta = 60^\\circ\\) \u2192 same range, different height and flight time Different \\(v_0\\) values shift the entire trajectory up/down Different \\(g\\) values (like Moon vs Earth) stretch the flight arc","title":"\ud83e\udde0 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-helper-code-just-for-later-use","text":"```python import numpy as np","title":"\ud83d\udcbb Python Helper Code (Just for Later Use)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"g = 9.81 # m/s\u00b2","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-function","text":"def range_formula(v0, theta_deg): theta_rad = np.radians(theta_deg) return (v0 ** 2 * np.sin(2 * theta_rad)) / g","title":"Range function"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range-numerical-simulation","text":"In this section, we simulate projectile range behavior with respect to the launch angle and analyze how initial velocity ( \\(v_0\\) ) and gravitational acceleration ( \\(g\\) ) influence the outcome.","title":"\ud83d\udcca 2\ufe0f\u20e3 Analysis of the Range \u2013 Numerical Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#objective","text":"Visualize the function: \\( \\(R(\\theta)=\\frac{v_0^2\\cdot\\sin(2\\theta)}{g}\\) \\) Explore: The symmetry around \\(\\theta=45^\\circ\\) The effect of changing \\(v_0\\) and \\(g\\) Optional: Non-zero launch height (extended model)","title":"\ud83c\udfaf Objective"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-range-vs-angle-multiple-cases","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Code: Range vs Angle (Multiple Cases)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants_1","text":"theta_deg = np.arange(0, 91, 1) # angles from 0\u00b0 to 90\u00b0 theta_rad = np.radians(theta_deg)","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#function-to-calculate-range","text":"def range_formula(v0, g, theta): return (v0**2 * np.sin(2 * theta)) / g","title":"Function to calculate range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#parameters-to-compare","text":"velocities = [50, 100, 150] # m/s gravities = [9.81, 1.62] # Earth & Moon gravity","title":"Parameters to compare"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-range-vs-angle-for-different-initial-velocities-earth","text":"plt.figure(figsize=(10, 5)) for v0 in velocities: R = range_formula(v0, 9.81, theta_rad) plt.plot(theta_deg, R, label=f\"v\u2080 = {v0} m/s\") plt.title(\"Range vs Angle for Different Initial Velocities (g = 9.81 m/s\u00b2)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Plot: Range vs Angle for different initial velocities (Earth)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plot-range-vs-angle-on-earth-vs-moon","text":"plt.figure(figsize=(10, 5)) for g in gravities: R = range_formula(100, g, theta_rad) label = \"Earth\" if g == 9.81 else \"Moon\" plt.plot(theta_deg, R, label=f\"{label} (g = {g} m/s\u00b2)\") plt.title(\"Range vs Angle: Earth vs Moon (v\u2080 = 100 m/s)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Plot: Range vs Angle on Earth vs Moon"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications-real-world-relevance-of-projectile-motion","text":"Projectile motion is more than just a theoretical exercise \u2014 it has significant applications in sports , engineering , and even space science . Understanding the factors that affect a projectile's trajectory allows us to model and optimize systems in various domains.","title":"\ud83c\udf0d 3\ufe0f\u20e3 Practical Applications \u2013 Real-World Relevance of Projectile Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#sports","text":"Many sports involve curved projectile trajectories. Understanding these helps in performance analysis, training, and even video game physics engines. Soccer : Curved free kicks follow projectile paths, especially when lofted. Basketball : The launch angle of a jump shot determines its chance of scoring. Golf : Club angle and speed determine the ball\u2019s range and height. All of these can be modeled using: \\[R=\\frac{v_0^2\\cdot\\sin(2\\theta)}{g}\\] But real cases often involve drag and spin.","title":"\ud83c\udfc0 Sports"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#engineering","text":"Engineers use projectile models in designing: Military/defense systems (cannons, missiles, mortars) Fireworks and flare trajectories Ballistics for forensics and law enforcement Precise modeling requires adding: - Air drag (quadratic with speed) - Mass of projectile - Wind vectors","title":"\ud83c\udfd7\ufe0f Engineering"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#astrophysics-space-science","text":"In astrophysics, projectile motion generalizes into orbital mechanics . Rocket launches begin with curved trajectories under Earth's gravity Escape velocity and reentry modeling depends on projectile motion with air resistance and changing \\(g\\) Also: - Gravity is not constant: \\( \\(g=\\frac{GM}{r^2}\\) \\) - Multi-stage motion must be modeled piecewise","title":"\ud83d\ude80 Astrophysics &amp; Space Science"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#uneven-terrain","text":"In real life, projectiles may land: On inclined planes Over hills, valleys, or obstacles This breaks the assumption that the launch and landing height are equal. The range formula becomes invalid, and we must solve: \\[y(t)=h+v_0\\cdot\\sin(\\theta)\\cdot t-\\frac{1}{2}gt^2\\] using numerical methods to find \\(t\\) when \\(y(t)=y_{\\text{target}}\\)","title":"\ud83c\udf04 Uneven Terrain"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#external-effects","text":"","title":"\ud83c\udf2c\ufe0f External Effects"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#air-resistance","text":"Air drag opposes motion. It depends on velocity and shape: \\[F_d=\\frac{1}{2}C_d\\rho Av^2\\] This turns motion into a system of nonlinear differential equations. It shortens range and lowers height.","title":"\ud83d\udca8 Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#wind","text":"Wind can: - Increase or decrease horizontal velocity - Deflect projectile laterally Simulation must include a horizontal force term.","title":"\ud83c\udf2a\ufe0f Wind"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#variable-gravity","text":"Gravity changes with altitude or location: On other planets (e.g., Mars \\(g=3.71\\) ) At high altitudes Or due to large terrain differences Use altitude-based gravity: \\[g(h)=\\frac{GM}{(R+h)^2}\\]","title":"\ud83c\udf15 Variable Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#for-accurate-modeling-in-atmospheric-reentry-or-lunar-missions","text":"","title":"for accurate modeling in atmospheric reentry or lunar missions."},{"location":"1%20Physics/1%20Mechanics/Problem_1/#summary","text":"Projectile motion is a versatile model with deep connections to reality. While the idealized equations are helpful, realistic modeling must incorporate: Uneven terrain Drag & wind Non-zero launch/landing heights Planet-specific gravity These improvements enable simulations that match the complexity of real-world systems.","title":"\u2705 Summary"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-simulating-projectile-motion-in-python","text":"In this section, we implement a Python-based simulation of projectile motion to analyze how range depends on launch angle, initial velocity, gravity, and launch height. We use the ideal range formula and extend it with optional height-based modeling.","title":"\ud83d\udcbb 4\ufe0f\u20e3 Implementation \u2013 Simulating Projectile Motion in Python"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#ideal-range-formula","text":"The ideal (no air resistance, flat ground) projectile range is given by: \\[R(\\theta)=\\frac{v_0^2\\cdot\\sin(2\\theta)}{g}\\] Where: - \\(R\\) is the range (meters) - \\(v_0\\) is the initial velocity (m/s) - \\(\\theta\\) is the launch angle (degrees) - \\(g\\) is gravitational acceleration (m/s\u00b2)","title":"\ud83d\udccc Ideal Range Formula"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-code-basic-implementation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Code: Basic Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#ideal-range-function","text":"def ideal_range(v0, g, theta_deg): theta_rad = np.radians(theta_deg) return (v0**2 * np.sin(2 * theta_rad)) / g angles = np.arange(0, 91, 1) g = 9.81 velocities = [50, 100, 150] plt.figure(figsize=(10, 5)) for v0 in velocities: ranges = ideal_range(v0, g, angles) plt.plot(angles, ranges, label=f\"v\u2080 = {v0} m/s\") plt.title(\"Projectile Range vs Launch Angle\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() gravities = [9.81, 1.62] # Earth and Moon gravity v0 = 100 plt.figure(figsize=(10, 5)) for g_val in gravities: ranges = ideal_range(v0, g_val, angles) label = \"Earth\" if g_val == 9.81 else \"Moon\" plt.plot(angles, ranges, label=f\"{label} (g = {g_val} m/s\u00b2)\") plt.title(\"Range vs Angle: Earth vs Moon (v\u2080 = 100 m/s)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show() from scipy.optimize import root_scalar def range_with_height(v0, g, theta_deg, h): theta_rad = np.radians(theta_deg) vy0 = v0 * np.sin(theta_rad) vx0 = v0 * np.cos(theta_rad) def y(t): return h + vy0 * t - 0.5 * g * t**2 sol = root_scalar(y, bracket=[0.01, 100], method='brentq') t_flight = sol.root return vx0 * t_flight heights = [0, 20, 50] v0 = 100 g = 9.81 plt.figure(figsize=(10, 5)) for h in heights: ranges = [range_with_height(v0, g, angle, h) for angle in angles] plt.plot(angles, ranges, label=f\"Launch Height = {h} m\") plt.title(\"Projectile Range vs Angle (with Launch Height)\") plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (meters)\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Ideal range function"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"\ud83d\udd2c Physics Assignment \u2013 KW1 Topic: Mechanics \u2013 Oscillations & Motion Author: Bartu867 Date: March 27, 2025 Problem 1 \u2013 Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfaf Goal Analyze the motion of a forced damped pendulum and observe how different parameters influence its behavior \u2014 including regular, resonant, and chaotic motion. \ud83d\udcd8 Theoretical Background The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: d\u00b2\u03b8/dt\u00b2 + b(d\u03b8/dt) + \u03c9\u2080\u00b2 sin(\u03b8) = A cos(\u03c9t) Where: - \u03b8: angular displacement - b: damping coefficient - \u03c9\u2080: natural frequency - A: amplitude of external force - \u03c9: driving frequency \ud83d\udd22 Reformulated System (First-Order) To apply numerical methods, the second-order ODE is transformed into two coupled first-order ODEs: Let \u03c9 = d\u03b8/dt, then: d\u03b8/dt = \u03c9 d\u03c9/dt = -b\u03c9 - \u03c9\u2080\u00b2 sin(\u03b8) + A cos(\u03c9t) \ud83e\udde0 Numerical Method: Runge-Kutta 4th Order (RK4) The RK4 method is used to solve the equations. The update steps for each time interval dt: \u03b8\u2099\u208a\u2081 = \u03b8\u2099 + (1/6)(k1_\u03b8 + 2k2_\u03b8 + 2k3_\u03b8 + k4_\u03b8) \u03c9\u2099\u208a\u2081 = \u03c9\u2099 + (1/6)(k1_\u03c9 + 2k2_\u03c9 + 2k3_\u03c9 + k4_\u03c9) \ud83d\udcbb Python Code \u2013 Pendulum Simulation ```python import numpy as np import matplotlib.pyplot as plt Parameters b = 0.5 # damping coefficient w0 = 1.5 # natural frequency A = 1.2 # driving force amplitude w = 0.666 # driving frequency dt = 0.04 # time step T = 100 # total simulation time Time array t = np.arange(0, T, dt) Arrays for theta and omega theta = np.zeros_like(t) omega = np.zeros_like(t) Initial conditions theta[0] = 0.2 omega[0] = 0.0 Runge-Kutta 4th order method for i in range(1, len(t)): k1_theta = dt * omega[i - 1] k1_omega = dt * (-b * omega[i - 1] - w0**2 * np.sin(theta[i - 1]) + A * np.cos(w * t[i - 1])) k2_theta = dt * (omega[i - 1] + 0.5 * k1_omega) k2_omega = dt * (-b * (omega[i - 1] + 0.5 * k1_omega) - w0**2 * np.sin(theta[i - 1] + 0.5 * k1_theta) + A * np.cos(w * (t[i - 1] + 0.5 * dt))) k3_theta = dt * (omega[i - 1] + 0.5 * k2_omega) k3_omega = dt * (-b * (omega[i - 1] + 0.5 * k2_omega) - w0**2 * np.sin(theta[i - 1] + 0.5 * k2_theta) + A * np.cos(w * (t[i - 1] + 0.5 * dt))) k4_theta = dt * (omega[i - 1] + k3_omega) k4_omega = dt * (-b * (omega[i - 1] + k3_omega) - w0**2 * np.sin(theta[i - 1] + k3_theta) + A * np.cos(w * (t[i - 1] + dt))) theta[i] = theta[i - 1] + (k1_theta + 2 * k2_theta + 2 * k3_theta + k4_theta) / 6 omega[i] = omega[i - 1] + (k1_omega + 2 * k2_omega + 2 * k3_omega + k4_omega) / 6 Plotting plt.figure(figsize=(10, 5)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum \u2013 Angular Displacement Over Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show()","title":"\ud83d\udd2c Physics Assignment \u2013 KW1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#physics-assignment-kw1","text":"Topic: Mechanics \u2013 Oscillations & Motion Author: Bartu867 Date: March 27, 2025","title":"\ud83d\udd2c Physics Assignment \u2013 KW1"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-1-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Problem 1 \u2013 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#goal","text":"Analyze the motion of a forced damped pendulum and observe how different parameters influence its behavior \u2014 including regular, resonant, and chaotic motion.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-background","text":"The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: d\u00b2\u03b8/dt\u00b2 + b(d\u03b8/dt) + \u03c9\u2080\u00b2 sin(\u03b8) = A cos(\u03c9t) Where: - \u03b8: angular displacement - b: damping coefficient - \u03c9\u2080: natural frequency - A: amplitude of external force - \u03c9: driving frequency","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#reformulated-system-first-order","text":"To apply numerical methods, the second-order ODE is transformed into two coupled first-order ODEs: Let \u03c9 = d\u03b8/dt, then: d\u03b8/dt = \u03c9 d\u03c9/dt = -b\u03c9 - \u03c9\u2080\u00b2 sin(\u03b8) + A cos(\u03c9t)","title":"\ud83d\udd22 Reformulated System (First-Order)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-method-runge-kutta-4th-order-rk4","text":"The RK4 method is used to solve the equations. The update steps for each time interval dt: \u03b8\u2099\u208a\u2081 = \u03b8\u2099 + (1/6)(k1_\u03b8 + 2k2_\u03b8 + 2k3_\u03b8 + k4_\u03b8) \u03c9\u2099\u208a\u2081 = \u03c9\u2099 + (1/6)(k1_\u03c9 + 2k2_\u03c9 + 2k3_\u03c9 + k4_\u03c9)","title":"\ud83e\udde0 Numerical Method: Runge-Kutta 4th Order (RK4)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-code-pendulum-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Code \u2013 Pendulum Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"b = 0.5 # damping coefficient w0 = 1.5 # natural frequency A = 1.2 # driving force amplitude w = 0.666 # driving frequency dt = 0.04 # time step T = 100 # total simulation time","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#time-array","text":"t = np.arange(0, T, dt)","title":"Time array"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#arrays-for-theta-and-omega","text":"theta = np.zeros_like(t) omega = np.zeros_like(t)","title":"Arrays for theta and omega"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#initial-conditions","text":"theta[0] = 0.2 omega[0] = 0.0","title":"Initial conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#runge-kutta-4th-order-method","text":"for i in range(1, len(t)): k1_theta = dt * omega[i - 1] k1_omega = dt * (-b * omega[i - 1] - w0**2 * np.sin(theta[i - 1]) + A * np.cos(w * t[i - 1])) k2_theta = dt * (omega[i - 1] + 0.5 * k1_omega) k2_omega = dt * (-b * (omega[i - 1] + 0.5 * k1_omega) - w0**2 * np.sin(theta[i - 1] + 0.5 * k1_theta) + A * np.cos(w * (t[i - 1] + 0.5 * dt))) k3_theta = dt * (omega[i - 1] + 0.5 * k2_omega) k3_omega = dt * (-b * (omega[i - 1] + 0.5 * k2_omega) - w0**2 * np.sin(theta[i - 1] + 0.5 * k2_theta) + A * np.cos(w * (t[i - 1] + 0.5 * dt))) k4_theta = dt * (omega[i - 1] + k3_omega) k4_omega = dt * (-b * (omega[i - 1] + k3_omega) - w0**2 * np.sin(theta[i - 1] + k3_theta) + A * np.cos(w * (t[i - 1] + dt))) theta[i] = theta[i - 1] + (k1_theta + 2 * k2_theta + 2 * k3_theta + k4_theta) / 6 omega[i] = omega[i - 1] + (k1_omega + 2 * k2_omega + 2 * k3_omega + k4_omega) / 6","title":"Runge-Kutta 4th order method"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plotting","text":"plt.figure(figsize=(10, 5)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum \u2013 Angular Displacement Over Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \u2013 Orbital Period and Orbital Radius Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025 \ud83c\udfaf Goal Understand and derive the relationship between the square of the orbital period and the cube of the orbital radius (Kepler\u2019s Third Law). Analyze this for circular orbits and simulate the behavior using Python for different celestial bodies. \ud83e\udde0 Theoretical Background Kepler\u2019s Third Law states that the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( r \\) for planets orbiting the same central body: \\[ T^2 \\propto r^3 \\] For circular orbits, using Newton\u2019s law of gravitation and centripetal force, the orbital period can be derived as: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Where: - \\( T \\) : orbital period (seconds) - \\( r \\) : orbital radius (meters) - \\( G \\) : gravitational constant \\( (6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2) \\) - \\( M \\) : mass of the central body (kg) This formula shows that the orbital period increases as the radius increases. \ud83d\udcbb Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.9722e24 # mass of the Earth (kg) # Orbital radius values (from 7e6 to 4.2e7 meters) r = np.linspace(7e6, 4.2e7, 500) # Orbital period calculation using Kepler's 3rd Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # in seconds # Plotting plt.figure(figsize=(10, 6)) plt.plot(r / 1e6, T / 3600, color=\"orange\") # Convert r to million meters, T to hours plt.title(\"Orbital Period vs Orbital Radius\") plt.xlabel(\"Orbital Radius (Million meters)\") plt.ylabel(\"Orbital Period (Hours)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 1 \u2013 Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025","title":"Problem 1 \u2013 Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#goal","text":"Understand and derive the relationship between the square of the orbital period and the cube of the orbital radius (Kepler\u2019s Third Law). Analyze this for circular orbits and simulate the behavior using Python for different celestial bodies.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-background","text":"Kepler\u2019s Third Law states that the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( r \\) for planets orbiting the same central body: \\[ T^2 \\propto r^3 \\] For circular orbits, using Newton\u2019s law of gravitation and centripetal force, the orbital period can be derived as: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Where: - \\( T \\) : orbital period (seconds) - \\( r \\) : orbital radius (meters) - \\( G \\) : gravitational constant \\( (6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2) \\) - \\( M \\) : mass of the central body (kg) This formula shows that the orbital period increases as the radius increases.","title":"\ud83e\udde0 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.9722e24 # mass of the Earth (kg) # Orbital radius values (from 7e6 to 4.2e7 meters) r = np.linspace(7e6, 4.2e7, 500) # Orbital period calculation using Kepler's 3rd Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # in seconds # Plotting plt.figure(figsize=(10, 6)) plt.plot(r / 1e6, T / 3600, color=\"orange\") # Convert r to million meters, T to hours plt.title(\"Orbital Period vs Orbital Radius\") plt.xlabel(\"Orbital Radius (Million meters)\") plt.ylabel(\"Orbital Period (Hours)\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025 \ud83c\udfaf Goal Examine how escape velocity varies with the mass and radius of a celestial body. Understand the concept of escape velocity and simulate how different planetary parameters affect it using Python. \ud83d\udcd8 Theoretical Background The escape velocity \\( v_e \\) is the minimum speed required for an object to break free from the gravitational pull of a massive body, without any further propulsion. The formula is derived from energy conservation: [ v_e = \\sqrt{\\frac{2GM}{R}} ] Where: - \\( v_e \\) : escape velocity (m/s) - \\( G \\) : gravitational constant \\( 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M \\) : mass of the celestial body (kg) - \\( R \\) : radius of the celestial body (m) \ud83d\udcbb Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674e-11 # Gravitational constant Example celestial body masses (kg) and radii (m) masses = np.array([5.972e24, 6.39e23, 1.898e27]) # Earth, Mars, Jupiter radii = np.array([6.371e6, 3.3895e6, 6.9911e7]) # Earth, Mars, Jupiter names = ['Earth', 'Mars', 'Jupiter'] Escape velocity calculation v_escape = np.sqrt(2 * G * masses / radii) Plotting plt.figure(figsize=(10,6)) plt.bar(names, v_escape, color='crimson') plt.title(\"Escape Velocity for Different Celestial Bodies\") plt.ylabel(\"Escape Velocity (m/s)\") plt.grid(axis='y') plt.tight_layout() plt.show()","title":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocity-and-celestial-bodies","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025","title":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#goal","text":"Examine how escape velocity varies with the mass and radius of a celestial body. Understand the concept of escape velocity and simulate how different planetary parameters affect it using Python.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theoretical-background","text":"The escape velocity \\( v_e \\) is the minimum speed required for an object to break free from the gravitational pull of a massive body, without any further propulsion. The formula is derived from energy conservation: [ v_e = \\sqrt{\\frac{2GM}{R}} ] Where: - \\( v_e \\) : escape velocity (m/s) - \\( G \\) : gravitational constant \\( 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M \\) : mass of the celestial body (kg) - \\( R \\) : radius of the celestial body (m)","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"G = 6.674e-11 # Gravitational constant","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#example-celestial-body-masses-kg-and-radii-m","text":"masses = np.array([5.972e24, 6.39e23, 1.898e27]) # Earth, Mars, Jupiter radii = np.array([6.371e6, 3.3895e6, 6.9911e7]) # Earth, Mars, Jupiter names = ['Earth', 'Mars', 'Jupiter']","title":"Example celestial body masses (kg) and radii (m)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity-calculation","text":"v_escape = np.sqrt(2 * G * masses / radii)","title":"Escape velocity calculation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plotting","text":"plt.figure(figsize=(10,6)) plt.bar(names, v_escape, color='crimson') plt.title(\"Escape Velocity for Different Celestial Bodies\") plt.ylabel(\"Escape Velocity (m/s)\") plt.grid(axis='y') plt.tight_layout() plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 29, 2025 \ud83c\udfaf Goal Simulate and analyze the possible trajectories of a payload released near Earth from a moving spacecraft. Determine whether the object enters orbit, falls to Earth, or escapes into space depending on initial conditions. \ud83d\udcd8 Theoretical Background When an object is released from a spacecraft near Earth, it will follow a trajectory determined by its initial velocity and position relative to Earth's gravity. Using Newton's law of universal gravitation: \\[ F = \\frac{GMm}{r^2} \\] The motion of the payload follows Newton's second law: \\[ F = ma \\Rightarrow a = \\frac{GM}{r^2} \\] Depending on the initial velocity vector: If \\( v < v_{\\text{orbit}} \\) , it falls back to Earth. If \\( v = v_{\\text{orbit}} \\) , it enters circular orbit. If \\( v > v_{\\text{escape}} \\) , it escapes Earth's gravity. We will simulate the trajectory by numerically integrating the motion under gravitational acceleration. \ud83d\udcbb Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R = 6.371e6 # radius of Earth (m) Initial conditions r0 = np.array([7.0e6, 0]) # initial position (just above Earth surface) v0 = np.array([0, 8000]) # initial velocity in m/s (tangential) Simulation parameters dt = 1 # time step (seconds) steps = 10000 # number of steps Arrays to store trajectory positions = np.zeros((steps, 2)) velocities = np.zeros((steps, 2)) Set initial values positions[0] = r0 velocities[0] = v0 Simulation loop for i in range(1, steps): r = positions[i-1] v = velocities[i-1] dist = np.linalg.norm(r) if dist < R: positions = positions[:i] # Break if the object is within Earth's radius break # Gravitational acceleration a = -G * M * r / dist**3 # Update velocity and position (Euler method) velocities[i] = v + a * dt positions[i] = r + velocities[i] * dt Plotting the trajectory x = positions[:, 0] / 1000 # Convert to km y = positions[:, 1] / 1000 # Convert to km plt.figure(figsize=(8,8)) plt.plot(x, y, label='Payload trajectory') circle = plt.Circle((0, 0), R / 1000, color='blue', alpha=0.5, label='Earth') plt.gca().add_patch(circle) plt.xlabel(\"x position (km)\") plt.ylabel(\"y position (km)\") plt.title(\"Trajectory of Payload Released Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 29, 2025","title":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#goal","text":"Simulate and analyze the possible trajectories of a payload released near Earth from a moving spacecraft. Determine whether the object enters orbit, falls to Earth, or escapes into space depending on initial conditions.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"When an object is released from a spacecraft near Earth, it will follow a trajectory determined by its initial velocity and position relative to Earth's gravity. Using Newton's law of universal gravitation: \\[ F = \\frac{GMm}{r^2} \\] The motion of the payload follows Newton's second law: \\[ F = ma \\Rightarrow a = \\frac{GM}{r^2} \\] Depending on the initial velocity vector: If \\( v < v_{\\text{orbit}} \\) , it falls back to Earth. If \\( v = v_{\\text{orbit}} \\) , it enters circular orbit. If \\( v > v_{\\text{escape}} \\) , it escapes Earth's gravity. We will simulate the trajectory by numerically integrating the motion under gravitational acceleration.","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R = 6.371e6 # radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"r0 = np.array([7.0e6, 0]) # initial position (just above Earth surface) v0 = np.array([0, 8000]) # initial velocity in m/s (tangential)","title":"Initial conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"dt = 1 # time step (seconds) steps = 10000 # number of steps","title":"Simulation parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#arrays-to-store-trajectory","text":"positions = np.zeros((steps, 2)) velocities = np.zeros((steps, 2))","title":"Arrays to store trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#set-initial-values","text":"positions[0] = r0 velocities[0] = v0","title":"Set initial values"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-loop","text":"for i in range(1, steps): r = positions[i-1] v = velocities[i-1] dist = np.linalg.norm(r) if dist < R: positions = positions[:i] # Break if the object is within Earth's radius break # Gravitational acceleration a = -G * M * r / dist**3 # Update velocity and position (Euler method) velocities[i] = v + a * dt positions[i] = r + velocities[i] * dt","title":"Simulation loop"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting-the-trajectory","text":"x = positions[:, 0] / 1000 # Convert to km y = positions[:, 1] / 1000 # Convert to km plt.figure(figsize=(8,8)) plt.plot(x, y, label='Payload trajectory') circle = plt.Circle((0, 0), R / 1000, color='blue', alpha=0.5, label='Earth') plt.gca().add_patch(circle) plt.xlabel(\"x position (km)\") plt.ylabel(\"y position (km)\") plt.title(\"Trajectory of Payload Released Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Plotting the trajectory"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}