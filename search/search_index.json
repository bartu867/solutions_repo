{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection Physics | Mechanics | KW1 Assignment Author: Bartu867 Date: March 29, 2025 \ud83c\udfaf Goal Simulate and analyze the possible trajectories of a projectile launched at different angles. Determine how the range depends on the angle of projection and calculate the range for different initial velocities. \ud83d\udcd8 Theoretical Background Projectile motion can be described by the following equations. The horizontal range of a projectile, ignoring air resistance, is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Where: - \\( v_0 \\) is the initial velocity - \\( \\theta \\) is the angle of projection - \\( g \\) is the gravitational acceleration In the case of air resistance, the equation becomes more complicated and requires numerical methods to solve. \ud83d\udcbb Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants g = 9.81 # gravitational acceleration (m/s^2) Function to calculate the range def calculate_range(v0, theta): return (v0 ** 2 * np.sin(2 * np.radians(theta))) / g Range calculation without air resistance theta_values = np.arange(0, 91, 1) # Angle range from 0 to 90 degrees v0 = 100 # Initial velocity in m/s ranges = calculate_range(v0, theta_values) Plotting the range vs. angle plt.figure(figsize=(8, 6)) plt.plot(theta_values, ranges, label='Range (No Air Resistance)', color='orange') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range of a Projectile as a Function of Launch Angle') plt.grid(True) plt.legend() plt.tight_layout() plt.show() Additional code for air resistance simulation def simulate_projectile_with_air_resistance(v0, theta, k, m): # Initial conditions x0, y0 = 0, 0 vx0 = v0 * np.cos(np.radians(theta)) vy0 = v0 * np.sin(np.radians(theta)) # Time settings dt = 0.01 t_max = 200 t_values = np.arange(0, t_max, dt) # Arrays to store positions x_values = np.zeros(len(t_values)) y_values = np.zeros(len(t_values)) vx_values = np.zeros(len(t_values)) vy_values = np.zeros(len(t_values)) x_values[0], y_values[0] = x0, y0 vx_values[0], vy_values[0] = vx0, vy0 for i in range(1, len(t_values)): # Air resistance ax = -k * vx_values[i-1] / m ay = -g - (k * vy_values[i-1] / m) # Update velocities and positions vx_values[i] = vx_values[i-1] + ax * dt vy_values[i] = vy_values[i-1] + ay * dt x_values[i] = x_values[i-1] + vx_values[i] * dt y_values[i] = y_values[i-1] + vy_values[i] * dt # Break if projectile hits the ground if y_values[i] < 0: break return x_values, y_values Simulate projectile with air resistance k = 0.1 # Drag coefficient m = 1 # Mass of the projectile x_vals, y_vals = simulate_projectile_with_air_resistance(v0, 45, k, m) Plotting the trajectory with air resistance plt.figure(figsize=(8, 6)) plt.plot(x_vals, y_vals, label='Projectile Trajectory (with Air Resistance)', color='blue') plt.xlabel('Distance (meters)') plt.ylabel('Height (meters)') plt.title('Projectile Trajectory with Air Resistance') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"Physics | Mechanics | KW1 Assignment Author: Bartu867 Date: March 29, 2025","title":"\ud83d\udef0\ufe0f Problem 1 \u2013 Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#goal","text":"Simulate and analyze the possible trajectories of a projectile launched at different angles. Determine how the range depends on the angle of projection and calculate the range for different initial velocities.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#theoretical-background","text":"Projectile motion can be described by the following equations. The horizontal range of a projectile, ignoring air resistance, is given by: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] Where: - \\( v_0 \\) is the initial velocity - \\( \\theta \\) is the angle of projection - \\( g \\) is the gravitational acceleration In the case of air resistance, the equation becomes more complicated and requires numerical methods to solve.","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#python-simulation","text":"","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"```python import numpy as np import matplotlib.pyplot as plt","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"g = 9.81 # gravitational acceleration (m/s^2)","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#function-to-calculate-the-range","text":"def calculate_range(v0, theta): return (v0 ** 2 * np.sin(2 * np.radians(theta))) / g","title":"Function to calculate the range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-calculation-without-air-resistance","text":"theta_values = np.arange(0, 91, 1) # Angle range from 0 to 90 degrees v0 = 100 # Initial velocity in m/s ranges = calculate_range(v0, theta_values)","title":"Range calculation without air resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plotting-the-range-vs-angle","text":"plt.figure(figsize=(8, 6)) plt.plot(theta_values, ranges, label='Range (No Air Resistance)', color='orange') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.title('Range of a Projectile as a Function of Launch Angle') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Plotting the range vs. angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#additional-code-for-air-resistance-simulation","text":"def simulate_projectile_with_air_resistance(v0, theta, k, m): # Initial conditions x0, y0 = 0, 0 vx0 = v0 * np.cos(np.radians(theta)) vy0 = v0 * np.sin(np.radians(theta)) # Time settings dt = 0.01 t_max = 200 t_values = np.arange(0, t_max, dt) # Arrays to store positions x_values = np.zeros(len(t_values)) y_values = np.zeros(len(t_values)) vx_values = np.zeros(len(t_values)) vy_values = np.zeros(len(t_values)) x_values[0], y_values[0] = x0, y0 vx_values[0], vy_values[0] = vx0, vy0 for i in range(1, len(t_values)): # Air resistance ax = -k * vx_values[i-1] / m ay = -g - (k * vy_values[i-1] / m) # Update velocities and positions vx_values[i] = vx_values[i-1] + ax * dt vy_values[i] = vy_values[i-1] + ay * dt x_values[i] = x_values[i-1] + vx_values[i] * dt y_values[i] = y_values[i-1] + vy_values[i] * dt # Break if projectile hits the ground if y_values[i] < 0: break return x_values, y_values","title":"Additional code for air resistance simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#simulate-projectile-with-air-resistance","text":"k = 0.1 # Drag coefficient m = 1 # Mass of the projectile x_vals, y_vals = simulate_projectile_with_air_resistance(v0, 45, k, m)","title":"Simulate projectile with air resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plotting-the-trajectory-with-air-resistance","text":"plt.figure(figsize=(8, 6)) plt.plot(x_vals, y_vals, label='Projectile Trajectory (with Air Resistance)', color='blue') plt.xlabel('Distance (meters)') plt.ylabel('Height (meters)') plt.title('Projectile Trajectory with Air Resistance') plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Plotting the trajectory with air resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \u2013 Investigating the Dynamics of a Forced Damped Pendulum Physics | Mechanics | KW1 Assignment Author: Bartu867 Date: March 27, 2025 \ud83c\udfaf Goal Analyze the motion of a forced damped pendulum and observe how different parameters influence its behavior \u2014 including regular, resonant, and chaotic motion. \ud83d\udcd8 Theoretical Background The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta \\) : angular displacement - \\( b \\) : damping coefficient - \\( \\omega_0 \\) : natural frequency - \\( A \\) : amplitude of external force - \\( \\omega \\) : driving frequency \ud83d\udcbb Python Simulation Below is a Python simulation of the pendulum using the Runge-Kutta 4th order method. ```python import numpy as np import matplotlib.pyplot as plt Parameters b = 0.5 # damping w0 = 1.5 # natural frequency A = 1.2 # driving force amplitude w = 0.666 # driving frequency dt = 0.04 # time step T = 100 # total time Time array t = np.arange(0, T, dt) Arrays for theta and omega theta = np.zeros_like(t) omega = np.zeros_like(t) Initial conditions theta[0] = 0.2 omega[0] = 0.0 Runge-Kutta 4th order method for i in range(1, len(t)): k1_theta = dt * omega[i - 1] k1_omega = dt * (-b * omega[i - 1] - w0**2 * np.sin(theta[i - 1]) + A * np.cos(w * t[i - 1])) k2_theta = dt * (omega[i - 1] + 0.5 * k1_omega) k2_omega = dt * (-b * (omega[i - 1] + 0.5 * k1_omega) - w0**2 * np.sin(theta[i - 1] + 0.5 * k1_theta) + A * np.cos(w * (t[i - 1] + 0.5 * dt))) k3_theta = dt * (omega[i - 1] + 0.5 * k2_omega) k3_omega = dt * (-b * (omega[i - 1] + 0.5 * k2_omega) - w0**2 * np.sin(theta[i - 1] + 0.5 * k2_theta) + A * np.cos(w * (t[i - 1] + 0.5 * dt))) k4_theta = dt * (omega[i - 1] + k3_omega) k4_omega = dt * (-b * (omega[i - 1] + k3_omega) - w0**2 * np.sin(theta[i - 1] + k3_theta) + A * np.cos(w * (t[i - 1] + dt))) theta[i] = theta[i - 1] + (k1_theta + 2 * k2_theta + 2 * k3_theta + k4_theta) / 6 omega[i] = omega[i - 1] + (k1_omega + 2 * k2_omega + 2 * k3_omega + k4_omega) / 6 Plotting plt.figure(figsize=(10, 5)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum \u2013 Angular Displacement Over Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show()","title":"Problem 2 \u2013 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2-investigating-the-dynamics-of-a-forced-damped-pendulum","text":"Physics | Mechanics | KW1 Assignment Author: Bartu867 Date: March 27, 2025","title":"Problem 2 \u2013 Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#goal","text":"Analyze the motion of a forced damped pendulum and observe how different parameters influence its behavior \u2014 including regular, resonant, and chaotic motion.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#theoretical-background","text":"The motion of a forced damped pendulum is governed by the second-order nonlinear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + b\\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\( \\theta \\) : angular displacement - \\( b \\) : damping coefficient - \\( \\omega_0 \\) : natural frequency - \\( A \\) : amplitude of external force - \\( \\omega \\) : driving frequency","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#python-simulation","text":"Below is a Python simulation of the pendulum using the Runge-Kutta 4th order method. ```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"b = 0.5 # damping w0 = 1.5 # natural frequency A = 1.2 # driving force amplitude w = 0.666 # driving frequency dt = 0.04 # time step T = 100 # total time","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#time-array","text":"t = np.arange(0, T, dt)","title":"Time array"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#arrays-for-theta-and-omega","text":"theta = np.zeros_like(t) omega = np.zeros_like(t)","title":"Arrays for theta and omega"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#initial-conditions","text":"theta[0] = 0.2 omega[0] = 0.0","title":"Initial conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#runge-kutta-4th-order-method","text":"for i in range(1, len(t)): k1_theta = dt * omega[i - 1] k1_omega = dt * (-b * omega[i - 1] - w0**2 * np.sin(theta[i - 1]) + A * np.cos(w * t[i - 1])) k2_theta = dt * (omega[i - 1] + 0.5 * k1_omega) k2_omega = dt * (-b * (omega[i - 1] + 0.5 * k1_omega) - w0**2 * np.sin(theta[i - 1] + 0.5 * k1_theta) + A * np.cos(w * (t[i - 1] + 0.5 * dt))) k3_theta = dt * (omega[i - 1] + 0.5 * k2_omega) k3_omega = dt * (-b * (omega[i - 1] + 0.5 * k2_omega) - w0**2 * np.sin(theta[i - 1] + 0.5 * k2_theta) + A * np.cos(w * (t[i - 1] + 0.5 * dt))) k4_theta = dt * (omega[i - 1] + k3_omega) k4_omega = dt * (-b * (omega[i - 1] + k3_omega) - w0**2 * np.sin(theta[i - 1] + k3_theta) + A * np.cos(w * (t[i - 1] + dt))) theta[i] = theta[i - 1] + (k1_theta + 2 * k2_theta + 2 * k3_theta + k4_theta) / 6 omega[i] = omega[i - 1] + (k1_omega + 2 * k2_omega + 2 * k3_omega + k4_omega) / 6","title":"Runge-Kutta 4th order method"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plotting","text":"plt.figure(figsize=(10, 5)) plt.plot(t, theta) plt.title(\"Forced Damped Pendulum \u2013 Angular Displacement Over Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.grid(True) plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \u2013 Orbital Period and Orbital Radius Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025 \ud83c\udfaf Goal Understand and derive the relationship between the square of the orbital period and the cube of the orbital radius (Kepler\u2019s Third Law). Analyze this for circular orbits and simulate the behavior using Python for different celestial bodies. \ud83e\udde0 Theoretical Background Kepler\u2019s Third Law states that the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( r \\) for planets orbiting the same central body: \\[ T^2 \\propto r^3 \\] For circular orbits, using Newton\u2019s law of gravitation and centripetal force, the orbital period can be derived as: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Where: - \\( T \\) : orbital period (seconds) - \\( r \\) : orbital radius (meters) - \\( G \\) : gravitational constant \\( (6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2) \\) - \\( M \\) : mass of the central body (kg) This formula shows that the orbital period increases as the radius increases. \ud83d\udcbb Python Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.9722e24 # mass of the Earth (kg) # Orbital radius values (from 7e6 to 4.2e7 meters) r = np.linspace(7e6, 4.2e7, 500) # Orbital period calculation using Kepler's 3rd Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # in seconds # Plotting plt.figure(figsize=(10, 6)) plt.plot(r / 1e6, T / 3600, color=\"orange\") # Convert r to million meters, T to hours plt.title(\"Orbital Period vs Orbital Radius\") plt.xlabel(\"Orbital Radius (Million meters)\") plt.ylabel(\"Orbital Period (Hours)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 1 \u2013 Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-orbital-period-and-orbital-radius","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025","title":"Problem 1 \u2013 Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#goal","text":"Understand and derive the relationship between the square of the orbital period and the cube of the orbital radius (Kepler\u2019s Third Law). Analyze this for circular orbits and simulate the behavior using Python for different celestial bodies.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_1/#theoretical-background","text":"Kepler\u2019s Third Law states that the square of the orbital period \\( T \\) is proportional to the cube of the orbital radius \\( r \\) for planets orbiting the same central body: \\[ T^2 \\propto r^3 \\] For circular orbits, using Newton\u2019s law of gravitation and centripetal force, the orbital period can be derived as: \\[ T = 2\\pi \\sqrt{\\frac{r^3}{GM}} \\] Where: - \\( T \\) : orbital period (seconds) - \\( r \\) : orbital radius (meters) - \\( G \\) : gravitational constant \\( (6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2) \\) - \\( M \\) : mass of the central body (kg) This formula shows that the orbital period increases as the radius increases.","title":"\ud83e\udde0 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.9722e24 # mass of the Earth (kg) # Orbital radius values (from 7e6 to 4.2e7 meters) r = np.linspace(7e6, 4.2e7, 500) # Orbital period calculation using Kepler's 3rd Law T = 2 * np.pi * np.sqrt(r**3 / (G * M)) # in seconds # Plotting plt.figure(figsize=(10, 6)) plt.plot(r / 1e6, T / 3600, color=\"orange\") # Convert r to million meters, T to hours plt.title(\"Orbital Period vs Orbital Radius\") plt.xlabel(\"Orbital Radius (Million meters)\") plt.ylabel(\"Orbital Period (Hours)\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025 \ud83c\udfaf Goal Examine how escape velocity varies with the mass and radius of a celestial body. Understand the concept of escape velocity and simulate how different planetary parameters affect it using Python. \ud83d\udcd8 Theoretical Background The escape velocity \\( v_e \\) is the minimum speed required for an object to break free from the gravitational pull of a massive body, without any further propulsion. The formula is derived from energy conservation: [ v_e = \\sqrt{\\frac{2GM}{R}} ] Where: - \\( v_e \\) : escape velocity (m/s) - \\( G \\) : gravitational constant \\( 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M \\) : mass of the celestial body (kg) - \\( R \\) : radius of the celestial body (m) \ud83d\udcbb Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674e-11 # Gravitational constant Example celestial body masses (kg) and radii (m) masses = np.array([5.972e24, 6.39e23, 1.898e27]) # Earth, Mars, Jupiter radii = np.array([6.371e6, 3.3895e6, 6.9911e7]) # Earth, Mars, Jupiter names = ['Earth', 'Mars', 'Jupiter'] Escape velocity calculation v_escape = np.sqrt(2 * G * masses / radii) Plotting plt.figure(figsize=(10,6)) plt.bar(names, v_escape, color='crimson') plt.title(\"Escape Velocity for Different Celestial Bodies\") plt.ylabel(\"Escape Velocity (m/s)\") plt.grid(axis='y') plt.tight_layout() plt.show()","title":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2-escape-velocity-and-celestial-bodies","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 27, 2025","title":"\ud83d\udef0\ufe0f Problem 2 \u2013 Escape Velocity and Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#goal","text":"Examine how escape velocity varies with the mass and radius of a celestial body. Understand the concept of escape velocity and simulate how different planetary parameters affect it using Python.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theoretical-background","text":"The escape velocity \\( v_e \\) is the minimum speed required for an object to break free from the gravitational pull of a massive body, without any further propulsion. The formula is derived from energy conservation: [ v_e = \\sqrt{\\frac{2GM}{R}} ] Where: - \\( v_e \\) : escape velocity (m/s) - \\( G \\) : gravitational constant \\( 6.674 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) - \\( M \\) : mass of the celestial body (kg) - \\( R \\) : radius of the celestial body (m)","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants","text":"G = 6.674e-11 # Gravitational constant","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_2/#example-celestial-body-masses-kg-and-radii-m","text":"masses = np.array([5.972e24, 6.39e23, 1.898e27]) # Earth, Mars, Jupiter radii = np.array([6.371e6, 3.3895e6, 6.9911e7]) # Earth, Mars, Jupiter names = ['Earth', 'Mars', 'Jupiter']","title":"Example celestial body masses (kg) and radii (m)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocity-calculation","text":"v_escape = np.sqrt(2 * G * masses / radii)","title":"Escape velocity calculation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plotting","text":"plt.figure(figsize=(10,6)) plt.bar(names, v_escape, color='crimson') plt.title(\"Escape Velocity for Different Celestial Bodies\") plt.ylabel(\"Escape Velocity (m/s)\") plt.grid(axis='y') plt.tight_layout() plt.show()","title":"Plotting"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 29, 2025 \ud83c\udfaf Goal Simulate and analyze the possible trajectories of a payload released near Earth from a moving spacecraft. Determine whether the object enters orbit, falls to Earth, or escapes into space depending on initial conditions. \ud83d\udcd8 Theoretical Background When an object is released from a spacecraft near Earth, it will follow a trajectory determined by its initial velocity and position relative to Earth's gravity. Using Newton's law of universal gravitation: \\[ F = \\frac{GMm}{r^2} \\] The motion of the payload follows Newton's second law: \\[ F = ma \\Rightarrow a = \\frac{GM}{r^2} \\] Depending on the initial velocity vector: If \\( v < v_{\\text{orbit}} \\) , it falls back to Earth. If \\( v = v_{\\text{orbit}} \\) , it enters circular orbit. If \\( v > v_{\\text{escape}} \\) , it escapes Earth's gravity. We will simulate the trajectory by numerically integrating the motion under gravitational acceleration. \ud83d\udcbb Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Constants G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R = 6.371e6 # radius of Earth (m) Initial conditions r0 = np.array([7.0e6, 0]) # initial position (just above Earth surface) v0 = np.array([0, 8000]) # initial velocity in m/s (tangential) Simulation parameters dt = 1 # time step (seconds) steps = 10000 # number of steps Arrays to store trajectory positions = np.zeros((steps, 2)) velocities = np.zeros((steps, 2)) Set initial values positions[0] = r0 velocities[0] = v0 Simulation loop for i in range(1, steps): r = positions[i-1] v = velocities[i-1] dist = np.linalg.norm(r) if dist < R: positions = positions[:i] # Break if the object is within Earth's radius break # Gravitational acceleration a = -G * M * r / dist**3 # Update velocity and position (Euler method) velocities[i] = v + a * dt positions[i] = r + velocities[i] * dt Plotting the trajectory x = positions[:, 0] / 1000 # Convert to km y = positions[:, 1] / 1000 # Convert to km plt.figure(figsize=(8,8)) plt.plot(x, y, label='Payload trajectory') circle = plt.Circle((0, 0), R / 1000, color='blue', alpha=0.5, label='Earth') plt.gca().add_patch(circle) plt.xlabel(\"x position (km)\") plt.ylabel(\"y position (km)\") plt.title(\"Trajectory of Payload Released Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3-trajectories-of-a-freely-released-payload-near-earth","text":"Physics | Gravity | KW1 Assignment Author: Bartu867 Date: March 29, 2025","title":"\ud83d\udef0\ufe0f Problem 3 \u2013 Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#goal","text":"Simulate and analyze the possible trajectories of a payload released near Earth from a moving spacecraft. Determine whether the object enters orbit, falls to Earth, or escapes into space depending on initial conditions.","title":"\ud83c\udfaf Goal"},{"location":"1%20Physics/2%20Gravity/Problem_3/#theoretical-background","text":"When an object is released from a spacecraft near Earth, it will follow a trajectory determined by its initial velocity and position relative to Earth's gravity. Using Newton's law of universal gravitation: \\[ F = \\frac{GMm}{r^2} \\] The motion of the payload follows Newton's second law: \\[ F = ma \\Rightarrow a = \\frac{GM}{r^2} \\] Depending on the initial velocity vector: If \\( v < v_{\\text{orbit}} \\) , it falls back to Earth. If \\( v = v_{\\text{orbit}} \\) , it enters circular orbit. If \\( v > v_{\\text{escape}} \\) , it escapes Earth's gravity. We will simulate the trajectory by numerically integrating the motion under gravitational acceleration.","title":"\ud83d\udcd8 Theoretical Background"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.674e-11 # gravitational constant (m^3/kg/s^2) M = 5.972e24 # mass of Earth (kg) R = 6.371e6 # radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"r0 = np.array([7.0e6, 0]) # initial position (just above Earth surface) v0 = np.array([0, 8000]) # initial velocity in m/s (tangential)","title":"Initial conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-parameters","text":"dt = 1 # time step (seconds) steps = 10000 # number of steps","title":"Simulation parameters"},{"location":"1%20Physics/2%20Gravity/Problem_3/#arrays-to-store-trajectory","text":"positions = np.zeros((steps, 2)) velocities = np.zeros((steps, 2))","title":"Arrays to store trajectory"},{"location":"1%20Physics/2%20Gravity/Problem_3/#set-initial-values","text":"positions[0] = r0 velocities[0] = v0","title":"Set initial values"},{"location":"1%20Physics/2%20Gravity/Problem_3/#simulation-loop","text":"for i in range(1, steps): r = positions[i-1] v = velocities[i-1] dist = np.linalg.norm(r) if dist < R: positions = positions[:i] # Break if the object is within Earth's radius break # Gravitational acceleration a = -G * M * r / dist**3 # Update velocity and position (Euler method) velocities[i] = v + a * dt positions[i] = r + velocities[i] * dt","title":"Simulation loop"},{"location":"1%20Physics/2%20Gravity/Problem_3/#plotting-the-trajectory","text":"x = positions[:, 0] / 1000 # Convert to km y = positions[:, 1] / 1000 # Convert to km plt.figure(figsize=(8,8)) plt.plot(x, y, label='Payload trajectory') circle = plt.Circle((0, 0), R / 1000, color='blue', alpha=0.5, label='Earth') plt.gca().add_patch(circle) plt.xlabel(\"x position (km)\") plt.ylabel(\"y position (km)\") plt.title(\"Trajectory of Payload Released Near Earth\") plt.axis(\"equal\") plt.grid(True) plt.legend() plt.tight_layout() plt.show()","title":"Plotting the trajectory"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}